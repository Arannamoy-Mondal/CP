# Blog link: https://www.geeksforgeeks.org/huffman-coding-in-cpp/
# For visualization: https://www.csfieldguide.org.nz/en/interactives/huffman-tree/ . Just paste your input on textbox and press on "Generate Tree"

এই কোডটি **হাফম্যান কোডিং অ্যালগরিদম** ব্যবহার করে একটি স্ট্রিংয়ের `character`গুলির জন্য কোড তৈরি করে। হাফম্যান কোডিং একটি ডেটা কম্প্রেশন অ্যালগরিদম, যেখানে ফ্রিকোয়েন্সি অনুযায়ী প্রতিটি `character` জন্য ছোট কোড নির্ধারণ করা হয়। বেশি ফ্রিকোয়েন্সির `character` জন্য ছোট কোড এবং কম ফ্রিকোয়েন্সির `character` জন্য বড় কোড তৈরি হয়। এই কোডটির মাধ্যমে এটি কার্যকরভাবে হাফম্যান ট্রি তৈরি করে এবং প্রতিটি `character` কোড বের করে।

### কোডের বিশ্লেষণ:

1. **Node ক্লাস**:
   - `Node` ক্লাসটি হাফম্যান ট্রির একটি নোড (গাছের একটি শাখা) প্রদর্শন করে। এটি নিম্নলিখিত গুণাবলী ধারণ করে:
     - `ch`: `character` (যা নোডটির প্রতিনিধিত্ব করে)।
     - `freq`: সেই `character` ফ্রিকোয়েন্সি।
     - `left` এবং `right`: এই নোডের বাম এবং ডান চাইল্ড নোডগুলির পয়েন্টার।
   - দুটি কনস্ট্রাক্টর:
     - একটির মাধ্যমে শুধু `character` এবং ফ্রিকোয়েন্সি সেট করা হয়।
     - অন্যটির মাধ্যমে দুটি নোডকে একত্রিত করে একটি নতুন নোড তৈরি করা হয় (এটি হাফম্যান ট্রি তৈরি করার সময় ব্যবহৃত হয়)।

2. **Comparator ক্লাস**:
   - `compare` ক্লাসটি প্রায়োরিটি কিউ (min-heap) এর জন্য একটি কাস্টম কম্প্যারেটর প্রদান করে। এটি ফ্রিকোয়েন্সি অনুসারে দুটি নোডের তুলনা করে, যাতে কম ফ্রিকোয়েন্সির নোড আগে আসে (যা হাফম্যান ট্রি তৈরির জন্য প্রয়োজনীয়)।

3. **printTree ফাংশন**:
   - `printTree` ফাংশনটি একটি রিকর্সিভ ফাংশন যা হাফম্যান ট্রির মাধ্যমে ট্র্যাভার্স করে এবং প্রতিটি `character` জন্য হাফম্যান কোড তৈরি করে।
   - এটি একটি `unordered_map<char, string>` ব্যবহার করে প্রতিটি `character` কোড সংরক্ষণ করে।
   - ফাংশনটি `0` এবং `1` অ্যাপেন্ড করে ট্রি traversing করে (বাম দিকে যাওয়ার সময় '0' এবং ডান দিকে যাওয়ার সময় '1')।

4. **Huffman Tree তৈরি**:
   - `buildHuffmanTree` ফাংশনটি হাফম্যান ট্রি তৈরি করার মূল অ্যালগরিদম:
     - প্রথমে এটি ইনপুট স্ট্রিংয়ের প্রতিটি `character` ফ্রিকোয়েন্সি গণনা করে এবং তা একটি `unordered_map<char, int>` তে রাখে।
     - তারপর প্রতিটি `character` এবং তার ফ্রিকোয়েন্সি একটি প্রায়োরিটি কিউ (min-heap) তে সন্নিবেশিত হয়।
     - পরবর্তীতে দুটি নোড বের করা হয় এবং তাদের একত্রিত করে একটি নতুন নোড তৈরি করা হয়, যা আবার কিউতে সন্নিবেশিত হয়।
     - এই প্রক্রিয়া চলতে থাকে যতক্ষণ না কিউতে একমাত্র একটি নোড (হাফম্যান ট্রির রুট) না থাকে।
     - পরিশেষে, `printTree` ফাংশনটি কল করা হয় এবং প্রতিটি `character` হাফম্যান কোড প্রিন্ট করা হয়।

5. **Main ফাংশন**:
   - `main` ফাংশনে একটি স্ট্যাটিক স্ট্রিং `"ABBCCCDDDDEEEEE"` দেওয়া হয়েছে এবং `buildHuffmanTree` ফাংশনটি কল করা হয়েছে। এটি কোডের কার্যকারিতা দেখাতে ব্যবহৃত হচ্ছে।
   
### আউটপুট:

যদি ইনপুট স্ট্রিং `"ABBCCCDDDDEEEEE"` হয়, তাহলে আউটপুট হবে:

```text
A
B
C
D
E
A 000
B 001
C 01
D 10
E 11
```

### আউটপুটের ব্যাখ্যা:
- প্রথমে প্রতিটি `character` এবং তার ফ্রিকোয়েন্সি আউটপুট হিসেবে মুদ্রিত হয়।
- পরে, হাফম্যান ট্রির মাধ্যমে প্রতিটি `character` জন্য কোড তৈরি হয় এবং তা প্রদর্শিত হয়। উদাহরণস্বরূপ:
  - 'A' এর কোড '000'
  - 'B' এর কোড '001'
  - 'C' এর কোড '01'
  - 'D' এর কোড '10'
  - 'E' এর কোড '11'

এখানে, 'E' এর ফ্রিকোয়েন্সি সবচেয়ে বেশি, তাই এটি সবচেয়ে ছোট কোড (11) পায়, এবং 'A' এর কোড সবচেয়ে বড় (000)।

### মন্তব্য:
- কোডে `"ABBCCCDDDDEEEEE"` ইনপুট স্ট্রিংটি হার্ডকোড করা হয়েছে, তবে এটি ইউজার ইনপুট নেওয়ার জন্য পরিবর্তনযোগ্য। 
- কোডে আউটপুটগুলো দেখতে ভালোভাবে বুঝতে পারার জন্য প্রয়োজনীয় ব্যাখ্যা দেওয়া হয়েছে।
- এই অ্যালগরিদমটি মূলত স্ট্রিং কম্প্রেশন বা ডেটা এনকোডিংয়ের জন্য ব্যবহৃত হয়, যাতে অধিক ফ্রিকোয়েন্সি থাকা `character`গুলির জন্য ছোট কোড তৈরি করা যায়।

এই কোডটি কার্যকরভাবে হাফম্যান কোডিং অ্যালগরিদম বাস্তবায়ন করে এবং ইনপুট স্ট্রিংয়ের জন্য প্রতিটি `character` কোড প্রিন্ট করে।



```c++

#include<bits/stdc++.h>/*
ChatGPT said:
সাধারণ C++ লাইব্রেরি (যেমন iostream, vector, algorithm, unordered_map, string, cmath, queue ইত্যাদি) একত্রে ইনক্লুড করতে পারেন।*/

using namespace std; 

/*
ChatGPT said:
C++ কোডে using namespace std; একটি খুব সাধারণ বিবৃতি যা স্ট্যান্ডার্ড লাইব্রেরির সকল উপাদানকে (যেমন ফাংশন,ক্লাস, অবজেক্ট ইত্যাদি) কোডে সরাসরি ব্যবহারের অনুমতি দেয়।*/


/*Explanation for class: 

ChatGPT said:
C++-এ ক্লাস (Class) হল একটি ডেটা টাইপ যা অবজেক্ট (object) তৈরি করার জন্য ব্যবহৃত হয়। এটি এক ধরনের ব্লুপ্রিন্ট বা টেমপ্লেট যা দ্বারা আমরা একাধিক অবজেক্ট তৈরি করতে পারি। একটি ক্লাসের মধ্যে ডেটা (যেমন: ভ্যারিয়েবল বা সদস্য ভেরিয়েবল) এবং ফাংশন (যেমন: সদস্য ফাংশন বা মেথড) থাকে, যেগুলি একসাথে কাজ করে।

*/
class Node{
    public:
    char ch;
    int freq;
    Node *left,*right;
    Node(char ch,int freq){
        this->ch=ch;
        this->freq=freq;
        this->left=NULL;
        this->right=NULL;
    }
    Node(char ch, int freq, Node* left, Node* right){
        this->ch=ch;
        this->freq=freq;
        this->left=left;
        this->right=right;
    }
};


class compare{
    /*
    C++-এ এই কোডটি একটি কম্পেয়ার ক্লাস (compare) তৈরি করে, যা একটি বিশেষ ধরনের ফাংশন অবজেক্ট (function object) বা ফান্সটর্স (functor) হিসাবে কাজ করে। এটি মূলত দুটি Node পয়েন্টারের মধ্যে তুলনা করে এবং তাদের ফ্রিকোয়েন্সি (freq) এর ভিত্তিতে একটি priority queue (অগ্রাধিকার কিউ) বা heap এর জন্য সঠিক অর্ডার তৈরি করতে ব্যবহৃত হয়।
    */
    public:
    bool operator ( )(Node *a,Node *b){
/*এই ফাংশনটি একটি ওভারলোড করা প্যারেন্টেসিস (overloaded parenthesis) অপারেটর ()। এটি C++ এর একটি বৈশিষ্ট্য, যার মাধ্যমে আপনি একটি ক্লাসের অবজেক্টকে ফাংশনের মতো ব্যবহার করতে পারেন।
এখানে, operator() ফাংশনটি দুটি Node পয়েন্টার (a এবং b) নিয়ে তাদের ফ্রিকোয়েন্সি (frequency) তুলনা করে।
*/
        return a->freq > b->freq;
    }   
};


void printTree(Node *root,string str,unordered_map<char,string>&mp){

    /*এই কোডটি একটি হাফম্যান ট্রি বা অন্য কোনও বাইনারি ট্রি প্রিন্ট করতে ব্যবহৃত হয়। ফাংশনটির নাম printTree এবং এটি ট্রির রুট থেকে শুরু করে প্রতিটি নোডে পৌঁছে যাওয়া পর্যন্ত ট্রি ট্র্যাভার্স (যাত্রা) করে। প্রতিটি leaf নোড (পাতা নোড) এর জন্য, তার একটি কোড (হাফম্যান কোড) তৈরি করে এবং সেই কোডটি একটি unordered_map এ সংরক্ষণ করে।*/

    if(root==NULL)return;/*যদি বর্তমান root নোডটি NULL হয়, অর্থাৎ আমরা গাছের শেষ (leaf) নোডে পৌঁছেছি বা একটি খালি গাছ দেখতে পাচ্ছি, তাহলে ফাংশনটি কোনো কাজ করবে না এবং ফিরে আসবে (return)।*/

    if(!root->left && !root->right){
        mp[root->ch]=str;
    }
    printTree(root->left,str+"0",mp);
    printTree(root->right,str+"1",mp);

/* এই শর্তটি চেক করে যে, বর্তমান নোডটি একটি leaf নোড কি না। অর্থাৎ, যদি নোডটির বাম এবং ডান চাইল্ড না থাকে, তবে এটি একটি leaf নোড।
যদি এটি একটি leaf নোড হয়, তখন আমরা সেই নোডের চরিত্র (root->ch) এবং তার কোড (str) unordered_map mp এ সঞ্চয় করি। mp[root->ch] = str; এখানে str হল সেই কোড, যা গাছের প্রতিটি স্তর পার হওয়ার সময় বাম চাইল্ডের জন্য "0" এবং ডান চাইল্ডের জন্য "1" যোগ করার ফলে তৈরি হয়।*/

}
void buildHuffmanTree(string s){

    priority_queue<Node*,vector<Node*>,compare>pq; 
/*
    priority_queue<Node*, vector<Node*>, compare> pq; এই লাইনটি একটি প্রায়োরিটি কিউ তৈরি করছে, যা Node* পয়েন্টার ধারণ করবে। compare ক্লাসের মাধ্যমে এটি ছোট ফ্রিকোয়েন্সি (min-heap) প্রাধান্য দেয়।
*/

    unordered_map<char,int>f;
    /*unordered_map<char, int> f; একটি ম্যাপ তৈরি করা হয়েছে, যেখানে Node ফ্রিকোয়েন্সি সংরক্ষণ করা হবে।*/

    for(auto it:s){
        f[it]++;
    }
    for(auto &[x,y]:f){
        /*for (auto &[x, y] : f) লুপটি ম্যাপের প্রতিটি ইনপুট নিয়ে কাজ করবে। এখানে x হচ্ছে Node er char ch এবং y হচ্ছে তার ফ্রিকোয়েন্সি।*/
        cout<<x<<endl;
        pq.push(new Node(x,y));
        /*
        প্রতিটি চরিত্র ও তার ফ্রিকোয়েন্সির জন্য একটি নতুন Node তৈরি করে, কিউতে সেই নোডটি প্রেরণ করা হচ্ছে। pq.push(new Node(x, y));।
        */
    }
    while(pq.size()!=1){
        Node* a=pq.top();
        pq.pop();
        Node* b=pq.top();
        pq.pop();
        pq.push(new Node('\0',a->freq+b->freq,a,b));
/*
এই লুপটি কিউটিতে একটিমাত্র নোড না থাকা পর্যন্ত চলবে।
প্রতিবার দুটি সর্বনিম্ন ফ্রিকোয়েন্সির নোড নির্বাচন করা হয় (a এবং b), তাদের একত্রিত করে একটি অভ্যন্তরীণ নোড তৈরি করা হয়। এই অভ্যন্তরীণ নোডটির ফ্রিকোয়েন্সি a->freq + b->freq হবে sum of a->freq and b->freq এবং এটি a ও b কে বাম ও ডান চাইল্ড হিসেবে ব্যবহার করবে। নতুন নোডটি আবার কিউতে যুক্ত হবে
*/
    }
    Node *root=pq.top();
    /*যখন কিউতে শুধুমাত্র একটিমাত্র নোড থাকবে, তখন সেটিই হবে আমাদের হাফম্যান ট্রি-এর রুট নোড। এই রুট নোডটি কিউ থেকে বের করে নেওয়া হয়।*/
    unordered_map<char,string>mp2;
    printTree(root,"",mp2);
    for(auto &[x,y]:mp2)cout<<x<<" "<<y<<endl;

    /*
    unordered_map<char, string> mp2; একটি ম্যাপ তৈরি করা হয়, যেখানে প্রতিটি alphabet character জন্য হাফম্যান কোড রাখা হবে।
printTree(root, "", mp2); কল করার মাধ্যমে root থেকে শুরু করে ট্রি ট্র্যাভার্স (যাত্রা) করা হয় এবং প্রতিটি leaf নোডের জন্য কোড তৈরি করা হয়। কোডগুলো mp2 ম্যাপে সংরক্ষিত হবে।
শেষে, for লুপে প্রতিটি alphabet character কোড প্রিন্ট করা হয়।

    */
}
int32_t main()
{
 string s="ABBCCCDDDDEEEEE";
//  cin>>s;
//  cout<<s<<endl;
 buildHuffmanTree(s);
}

/*হাফম্যান ট্রি এমনভাবে সাজানো হবে, যে কম ফ্রিকোয়েন্সি alphabet character কোড ছোট হবে এবং বেশি ফ্রিকোয়েন্সি alphabet character কোড দীর্ঘ হবে।*/
```
